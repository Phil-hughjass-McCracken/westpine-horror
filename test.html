<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Westpine Night — 2.0</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0a0a0f; color:#e6e6f0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
    #ui { position: fixed; inset: 0 0 auto 0; display:flex; gap:12px; align-items:center; padding:10px 14px; background: linear-gradient(180deg, rgba(10,10,15,.9), rgba(10,10,15,.25)); backdrop-filter: blur(4px); z-index: 10; }
    #ui .pill { padding:4px 10px; border-radius:14px; background:#1b1b25; border:1px solid #2b2b38; box-shadow: inset 0 0 0 1px rgba(255,255,255,.03); font-size: 14px; }
    #ui .right { margin-left:auto; opacity:.95 }
    #ui .inv { display:flex; gap:8px; align-items:center; }
    #game { display:block; margin:0 auto; image-rendering: pixelated; }
    #overlay { position: fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.8); z-index: 20; }
    #overlay .card { background:#121219; border:1px solid #2b2b38; border-radius:16px; padding:20px; width:min(680px, 92vw); text-align:center; box-shadow: 0 10px 30px rgba(0,0,0,.6); }
    #overlay h1 { margin:0 0 8px; font-size:28px; }
    #overlay p { margin:8px 0 16px; line-height:1.5 }
    #overlay button { background:#2b2bff; border:0; color:white; padding:10px 16px; border-radius:10px; cursor:pointer; font-weight:600; }
    #overlay button.secondary { background:#1b1b25; border:1px solid #2b2b38; margin-left:8px; }
    #alert { position: fixed; right:12px; bottom:12px; background:#3a0d0d; color:#ffb3b3; padding:8px 12px; border:1px solid #5c1717; border-radius:10px; display:none; font-weight:700; z-index: 15; }
    #changelog-popup { position:fixed; inset:0; background:rgba(0,0,0,.85); display:none; justify-content:center; align-items:center; z-index: 30; }
    #changelog-content { background:#121219; border:1px solid #2b2b38; border-radius:16px; padding:20px; width:min(680px, 92vw); max-height:80vh; overflow-y:auto; text-align:left; box-shadow: 0 10px 30px rgba(0,0,0,.6); }
    #changelog-content h2 { margin-top:0; }
    #changelog-content ul { padding-left:20px; }
    #changelog-content li { margin-bottom:8px; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="pill">WASD/Arrows: Move</div>
    <div class="pill">Shift: Sprint (noise!)</div>
    <div class="pill">F: Flashlight</div>
    <div class="pill">E: Interact/Hide/Hack</div>
    <div class="pill right inv">Keys: <span id="keys">0</span>/4 · Pennants: <span id="pennants">0</span>/5 · Stamina: <span id="stamina">100</span>% · Hidden: <span id="hidden">No</span> · Cams: <span id="cams">Online</span></div>
  </div>
  <canvas id="game" width="960" height="576"></canvas>
  <div id="overlay">
    <div class="card">
      <h1 id="title">Westpine Night 2.0</h1>
      <p id="message">New: bigger scrolling map, flickering lights, camera terminals, inventory HUD, enterable classrooms, hearing & fake-outs<br/>Collect <b>4 keys</b>, avoid Mr. Johnson, hide in <b>lockers</b>, hack <b>camera terminals</b>, and get to the Principal's Office door.</p>
      <div>
        <button id="play">Play</button>
        <button id="retry" class="secondary" style="display:none">Retry</button>
        <button id="changelog-btn" class="secondary">Changelog</button>
      </div>
    </div>
  </div>
  <div id="alert">ALERT: Camera spotted you!</div>
  
  <div id="changelog-popup">
    <div id="changelog-content">
      <h2>Changelog</h2>
      <ul>
        <li>**v2.1 (August 2025)**
          <ul>
            <li>**Randomized Key Spawns:** Keys now spawn in random locations, making each playthrough a new challenge.</li>
            <li>**New Collectibles:** Added 5 "Westpine Pennants" hidden throughout the map for players to find.</li>
            <li>**New Interactables:**
              <ul>
                <li>**Noise Makers:** Use E to activate a distraction and lure Mr. Johnson away.</li>
                <li>**Barricades:** Use E to break through certain walls, creating new paths. (Warning: They are loud!)</li>
              </ul>
            </li>
            <li>**Reduced Light Flickering:** The frequency of lights flickering has been lowered to make these moments more dramatic.</li>
            <li>**Minor Bug Fixes:** Squashed some minor bugs and made performance improvements.</li>
          </ul>
        </li>
        <li>**v2.0 (June 2025)**
          <ul>
            <li>Initial public release with scrolling map, enemy AI, and camera systems.</li>
          </ul>
        </li>
      </ul>
      <button id="close-changelog" style="display:block; margin:20px auto 0;">Close</button>
    </div>
  </div>

  <script>
  // --- Westpine Night 2.1: scrolling-map stealth prototype (single file, no assets) ---
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  const uiKeys = document.getElementById('keys');
  const uiPennants = document.getElementById('pennants');
  const uiStam = document.getElementById('stamina');
  const uiHidden = document.getElementById('hidden');
  const uiCams = document.getElementById('cams');
  const overlay = document.getElementById('overlay');
  const titleEl = document.getElementById('title');
  const msgEl = document.getElementById('message');
  const playBtn = document.getElementById('play');
  const retryBtn = document.getElementById('retry');
  const changelogBtn = document.getElementById('changelog-btn');
  const changelogPopup = document.getElementById('changelog-popup');
  const closeChangelogBtn = document.getElementById('close-changelog');
  const alertEl = document.getElementById('alert');

  const TILE = 32; // pixels per tile

  // Map legend: 1=wall, 0=floor, 2=spawn, 4=key, 5=locker, 6=camera terminal, 7=principal office door
  // New: 8=noise maker, 9=pennant, 10=barricade
  const MAP = [
    // 0           5         10         15         20         25         30         35         40
    //            |          |          |          |          |          |          |          |
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,0,0,0,0,0,0,1,0,5,5,0,0,0,0,1,0,0,0,0,1,0,0,0,4,0,0,0,0,1,0,0,0,0,0,6,0,0,1],
    [1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,1,1,0,5,0,0,0,1,1,0,0,5,0,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,5,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,5,1,0,0,1],
    [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,4,0,1],
    [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,5,0,0,0,0,0,1,0,0,0,0,5,0,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,6,1,0,0,1],
    [1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,1,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,5,1,0,0,1],
    [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,0,0,1,0,7,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
    [1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,4,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,5,1,0,0,1],
    [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
    [1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,5,1,0,0,1],
    [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  ];

  const ROWS = MAP.length;
  const COLS = MAP[0].length;

  const keysToCollect = 4;
  const pennantsToCollect = 5;

  function findTile(n){
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(MAP[r][c]===n) return {x:c*TILE+TILE/2, y:r*TILE+TILE/2};
    return {x:TILE*2, y:TILE*2};
  }

  const spawn = findTile(2);
  // Principal's Office door tile (7) is the true exit
  function findAllTiles(n){ const arr=[]; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(MAP[r][c]===n) arr.push({x:c*TILE+TILE/2, y:r*TILE+TILE/2, r, c}); return arr; }
  const officeDoor = findAllTiles(7)[0];

  // Entities
  const player = { x: spawn.x, y: spawn.y, r: 12, speed: 2.1, sprint: 3.3, vx:0, vy:0, stamina: 100, flashlight:false, facing:0, hidden:false };
  const enemy = { x: spawn.x+200, y: spawn.y+40, r:14, speed:1.85, fov: Math.PI/4.5, baseRange: 260, alert:false, target:null, patrol:[], patrolIndex:0, cooldown:0, fakeoutTimer:0 };

  // Camera scroll
  const cam = { x: 0, y: 0 };

  // Build patrol waypoints roughly around main halls
  enemy.patrol = [
    {x: TILE*8,  y: TILE*3},
    {x: TILE*8,  y: TILE*16},
    {x: TILE*22, y: TILE*16},
    {x: TILE*34, y: TILE*16},
    {x: TILE*34, y: TILE*4},
    {x: TILE*22, y: TILE*4},
  ];

  // Collectibles spawn locations
  const keySpawnPoints = findAllTiles(4);
  const pennantSpawnPoints = [
    {x:TILE*2.5, y:TILE*8.5, taken:false, r:8, c:2}, // in classroom
    {x:TILE*14.5, y:TILE*16.5, taken:false, r:16, c:14}, // by lockers
    {x:TILE*25.5, y:TILE*1.5, taken:false, r:1, c:25}, // corner
    {x:TILE*33.5, y:TILE*21.5, taken:false, r:21, c:33}, // far corner
    {x:TILE*18.5, y:TILE*18.5, taken:false, r:18, c:18}, // middle area
  ];
  const noiseMakers = [
    {x:TILE*35.5, y:TILE*1.5, used:false, r:1, c:35}, // in gym area
    {x:TILE*3.5, y:TILE*1.5, used:false, r:1, c:3} // by spawn
  ];
  const barricades = [
    {x: TILE*1.5, y: TILE*22.5, broken: false, r: 22, c: 1}, // bottom left
    {x: TILE*19.5, y: TILE*11.5, broken: false, r: 11, c: 19}, // middle wall
  ]

  // Keys spawn (tile==4)
  let keys = [];
  let heldKeys = 0;
  let heldPennants = 0;

  // Lockers (tile==5)
  let lockers = [];
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(MAP[r][c]===5) lockers.push({x:c*TILE+TILE/2, y:r*TILE+TILE/2});

  // Terminals (tile==6)
  let terminals = [];
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(MAP[r][c]===6) terminals.push({x:c*TILE+TILE/2, y:r*TILE+TILE/2});

  // Cameras
  const cameras = [
    {x:TILE*10.5, y:TILE*2.5, range:240, fov:Math.PI/5, angle:0, min:-Math.PI/3, max:Math.PI/3, dir:1, speed:0.01, cooldown:0},
    {x:TILE*22.5, y:TILE*12.5, range:260, fov:Math.PI/5, angle:Math.PI, min:Math.PI-0.9, max:Math.PI+0.9, dir:1, speed:0.012, cooldown:0},
    {x:TILE*35.5, y:TILE*4.5,  range:220, fov:Math.PI/6, angle:Math.PI/2, min:Math.PI/2-0.7, max:Math.PI/2+0.7, dir:1, speed:0.009, cooldown:0},
    {x:TILE*16.5, y:TILE*8.5,  range:220, fov:Math.PI/6, angle:-Math.PI/2, min:-Math.PI/2-0.7, max:-Math.PI/2+0.7, dir:1, speed:0.011, cooldown:0},
  ];

  // Systems
  let running = false;
  let gameOver = false;
  let won = false;
  let camAlertTimer = 0;
  let camerasDisabledTimer = 0; // when >0, cameras ignore you

  // Lighting
  let lightLevel = 1; // 1 = normal, <1 = darker
  let flickerTimer = 0; // small flickers
  let blackoutTimer = 0; // full darkness moments

  // Hearing
  const HEAR_RANGE = 280; // Johnson hears sprinting within this range

  const input = { up:false, down:false, left:false, right:false, sprint:false, interact:false };
  onkeydown = e => {
    if(e.key==='ArrowUp'||e.key==='w') input.up=true;
    if(e.key==='ArrowDown'||e.key==='s') input.down=true;
    if(e.key==='ArrowLeft'||e.key==='a') input.left=true;
    if(e.key==='ArrowRight'||e.key==='d') input.right=true;
    if(e.key==='Shift') input.sprint=true;
    if(e.key==='f' || e.key==='F') player.flashlight = !player.flashlight;
    if(e.key==='e' || e.key==='E') input.interact = true;
  }
  onkeyup = e => {
    if(e.key==='ArrowUp'||e.key==='w') input.up=false;
    if(e.key==='ArrowDown'||e.key==='s') input.down=false;
    if(e.key==='ArrowLeft'||e.key==='a') input.left=false;
    if(e.key==='ArrowRight'||e.key==='d') input.right=false;
    if(e.key==='e' || e.key==='E') input.interact = false;
  }

  function tileAt(x,y){
    const c = Math.floor(x / TILE), r = Math.floor(y / TILE);
    if(r<0||r>=ROWS||c<0||c>=COLS) return 1; // outside is wall
    return MAP[r][c];
  }

  function collideCircleWalls(obj){
    // stop at walls along axes
    if(tileAt(obj.x+obj.vx+Math.sign(obj.vx)*obj.r, obj.y)===1 || (MAP[Math.floor(obj.y/TILE)][Math.floor((obj.x+obj.vx+Math.sign(obj.vx)*obj.r)/TILE)] === 10 && !barricades.find(b => b.r === Math.floor(obj.y/TILE) && b.c === Math.floor((obj.x+obj.vx+Math.sign(obj.vx)*obj.r)/TILE)).broken)) obj.vx = 0;
    if(tileAt(obj.x, obj.y+obj.vy+Math.sign(obj.vy)*obj.r)===1 || (MAP[Math.floor((obj.y+obj.vy+Math.sign(obj.vy)*obj.r)/TILE)][Math.floor(obj.x/TILE)] === 10 && !barricades.find(b => b.r === Math.floor((obj.y+obj.vy+Math.sign(obj.vy)*obj.r)/TILE) && b.c === Math.floor(obj.x/TILE)).broken)) obj.vy = 0;
    if(tileAt(obj.x+Math.sign(obj.vx)*obj.r, obj.y+Math.sign(obj.vy)*obj.r)===1){ obj.vx=0; obj.vy=0; }
  }

  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function angle(a,b){ return Math.atan2(b.y-a.y, b.x-a.x); }
  function clamp(v,mi,ma){ return Math.max(mi, Math.min(ma, v)); }

  function canSeeCone(from,to, angleCenter, fov, maxDist){
    const ang = angle({x:from.x,y:from.y},to);
    const withinCone = Math.abs(normalizeAngle(ang - angleCenter)) <= fov/2;
    if(!withinCone) return false;
    const d = dist(from, to); if(d>maxDist) return false;
    // raycast
    const steps = Math.ceil(d/6);
    for(let i=1;i<=steps;i++){
      const px = from.x + (to.x-from.x)*(i/steps);
      const py = from.y + (to.y-from.y)*(i/steps);
      const t = tileAt(px,py);
      if(t===1 || (t === 10 && !barricades.find(b => b.r === Math.floor(py/TILE) && b.c === Math.floor(px/TILE)).broken)) return false;
    }
    return true;
  }

  function canSeeEnemy(){
    const ambient = blackoutTimer>0 ? 0.6 : (0.8 + 0.2*lightLevel); // darker -> less range
    const baseRange = enemy.baseRange * ambient * (player.flashlight ? 1.15 : 1.0);
    const facing = enemyFacing(enemy);
    return canSeeCone(enemy, player, facing, enemy.fov, baseRange);
  }

  function normalizeAngle(a){ while(a>Math.PI) a-=2*Math.PI; while(a<-Math.PI) a+=2*Math.PI; return a; }
  function enemyFacing(e){
    if(e.target){ return angle(e, e.target); }
    const next = e.patrol[(e.patrolIndex)%e.patrol.length];
    return angle(e,next);
  }

  function nearThing(list, radius=24){ for(const p of list){ if(dist(player,p)<radius) return p; } return null; }
  function nearLocker(){ return nearThing(lockers, 26); }
  function nearTerminal(){ return nearThing(terminals, 28); }
  function nearNoiseMaker(){ return nearThing(noiseMakers, 28); }
  function nearBarricade(){ return nearThing(barricades, 28); }
  function nearOfficeDoor(){ return dist(player, officeDoor)<28; }

  function tryInteract(){
    if(player.hidden){ player.hidden=false; player.flashlight=false; uiHidden.textContent='No'; return; }
    
    // Terminals
    const term = nearTerminal();
    if(term){ camerasDisabledTimer = 60*30; uiCams.textContent = 'Offline'; return; }

    // Lockers
    const locker = nearLocker();
    if(locker){ player.hidden=true; player.vx=player.vy=0; player.flashlight=false; uiHidden.textContent='Yes'; return; }

    // Barricades
    const bar = nearBarricade();
    if(bar && !bar.broken){
      bar.broken = true;
      MAP[bar.r][bar.c] = 0; // Change to floor tile
      // Noise
      enemy.alert = true;
      enemy.target = {x: player.x, y: player.y};
      enemy.cooldown = 480; // Longer cooldown for loud noise
      return;
    }

    // Noise makers
    const nm = nearNoiseMaker();
    if(nm && !nm.used){
      nm.used = true;
      enemy.alert = true;
      enemy.target = {x: nm.x, y: nm.y};
      enemy.cooldown = 360; // 6 seconds
      return;
    }

    if(heldKeys>=keysToCollect && nearOfficeDoor()){ won=true; endGame(); return; }
  }

  function randomizeKeys(){
    // Shuffle the key spawn points
    for (let i = keySpawnPoints.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [keySpawnPoints[i], keySpawnPoints[j]] = [keySpawnPoints[j], keySpawnPoints[i]];
    }

    // Assign the first 4 points as keys and the rest as floor
    keys = [];
    for(let i=0; i<keySpawnPoints.length; i++){
      const p = keySpawnPoints[i];
      MAP[p.r][p.c] = (i < keysToCollect) ? 4 : 0;
      if (i < keysToCollect) {
        keys.push({x:p.x, y:p.y, taken:false});
      }
    }
  }

  function reset(){
    randomizeKeys();
    player.x = spawn.x; player.y = spawn.y; player.stamina=100; player.flashlight=false; player.hidden=false; heldKeys=0; heldPennants=0;
    
    // Reset collectibles, distractions, and barricades
    pennantSpawnPoints.forEach(p => p.taken = false);
    noiseMakers.forEach(nm => nm.used = false);
    barricades.forEach(bar => { bar.broken = false; MAP[bar.r][bar.c] = 10; });

    enemy.x = spawn.x+200; enemy.y = spawn.y+40; enemy.alert=false; enemy.target=null; enemy.patrolIndex=0; enemy.cooldown=0; enemy.fakeoutTimer=0;
    camAlertTimer = 0; alertEl.style.display='none';
    camerasDisabledTimer = 0; uiCams.textContent='Online';
    lightLevel = 1; flickerTimer=0; blackoutTimer=0;
    running = true; gameOver=false; won=false;
    overlay.style.display='none';
    retryBtn.style.display='none';
    playBtn.style.display='inline-block';
  }

  playBtn.onclick = () => { reset(); };
  retryBtn.onclick = () => { reset(); };
  changelogBtn.onclick = () => { changelogPopup.style.display = 'flex'; };
  closeChangelogBtn.onclick = () => { changelogPopup.style.display = 'none'; };

  // Start menu shown initially
  overlay.style.display='flex';

  function update(){
    // ALWAYS schedule next frame so the loop keeps running
    requestAnimationFrame(update);

    // Camera follow
    cam.x = clamp(player.x - W/2, 0, COLS*TILE - W);
    cam.y = clamp(player.y - H/2, 0, ROWS*TILE - H);

    if(!running){ draw(); return; }

    // --- Lighting effects ---
    if(blackoutTimer>0){ blackoutTimer--; lightLevel = 0.25; }
    else {
      if(flickerTimer>0){ flickerTimer--; lightLevel = 0.7 + Math.random()*0.2; }
      else { lightLevel = 1; if(Math.random()<0.001) flickerTimer = 40; if(Math.random()<0.0003) blackoutTimer = 180; }
    }

    // --- Input & Interaction ---
    if(input.interact){ tryInteract(); input.interact=false; }

    // --- Player movement ---
    if(!player.hidden){
      const spd = (input.sprint && player.stamina>0) ? player.sprint : player.speed;
      player.vx = (input.right - input.left) * spd;
      player.vy = (input.down - input.up) * spd;
      if(player.vx && player.vy){ player.vx *= 0.7071; player.vy *= 0.7071; }
      // stamina drain/regain
      const moving = (player.vx||player.vy);
      if(input.sprint && moving) player.stamina = Math.max(0, player.stamina - 0.25);
      else player.stamina = Math.min(100, player.stamina + 0.15);
      collideCircleWalls(player);
      player.x += player.vx; player.y += player.vy;
      if(moving) player.facing = Math.atan2(player.vy, player.vx);

      // noise from sprinting
      if(input.sprint && moving){
        const d = dist(player, enemy);
        if(d < HEAR_RANGE){ enemy.alert = true; enemy.target = {x:player.x, y:player.y}; enemy.cooldown = 180; }
      }
    } else {
      // hidden: recover stamina faster
      player.stamina = Math.min(100, player.stamina + 0.4);
    }

    // collect keys
    for(const k of keys){ if(!k.taken && dist(player,k)<18){ k.taken=true; heldKeys++; } }

    // collect pennants
    for(const p of pennantSpawnPoints){ if(!p.taken && dist(player,p)<18){ p.taken=true; heldPennants++; } }

    // --- Cameras ---
    if(camerasDisabledTimer>0){ camerasDisabledTimer--; if(camerasDisabledTimer===0) uiCams.textContent='Online'; }
    for(const camObj of cameras){
      // sweep
      camObj.angle += camObj.speed * camObj.dir;
      if(camObj.angle>camObj.max){ camObj.angle=camObj.max; camObj.dir*=-1; }
      if(camObj.angle<camObj.min){ camObj.angle=camObj.min; camObj.dir*=-1; }

      if(player.hidden) continue;
      if(camerasDisabledTimer>0) continue;
      if(canSeeCone(camObj, player, camObj.angle, camObj.fov, camObj.range)){
        camObj.cooldown = 180; // 3s memory
        camAlertTimer = 60; // show UI alert
        alertEl.style.display='block';
        // ping enemy to investigate
        enemy.alert = true;
        enemy.target = {x: player.x, y: player.y};
        enemy.cooldown = 300;
      } else if(camObj.cooldown>0){ camObj.cooldown--; }
    }
    if(camAlertTimer>0){ camAlertTimer--; if(camAlertTimer===0) alertEl.style.display='none'; }

    // --- Enemy AI ---
    const seen = !player.hidden && canSeeEnemy();

    // trailing fake-out: if player hangs near behind enemy
    if(!enemy.alert && !player.hidden){
      const toPlayer = angle(enemy, player);
      const face = enemyFacing(enemy);
      const behind = Math.abs(normalizeAngle(toPlayer - face)) > Math.PI*0.7; // roughly behind
      if(behind && dist(player, enemy) < 140){ if(enemy.fakeoutTimer<=0) enemy.fakeoutTimer = 60; }
    }

    if(seen){ enemy.alert = true; enemy.target = {x:player.x, y:player.y}; enemy.cooldown = 240; enemy.fakeoutTimer = 0; }
    else { if(enemy.cooldown>0) enemy.cooldown--; else enemy.alert=false; }

    if(enemy.alert){
      const ang = angle(enemy, enemy.target);
      const spd = enemy.speed + 0.4;
      enemy.x += Math.cos(ang) * spd;
      enemy.y += Math.sin(ang) * spd;
      if(dist(enemy, enemy.target)<12) enemy.alert=false;
    } else {
      // fake-out burst toward previous waypoint
      if(enemy.fakeoutTimer>0){
        enemy.fakeoutTimer--;
        const prevIndex = (enemy.patrolIndex - 1 + enemy.patrol.length) % enemy.patrol.length;
        const wp = enemy.patrol[prevIndex];
        const ang = angle(enemy, wp);
        enemy.x += Math.cos(ang) * (enemy.speed + 0.8);
        enemy.y += Math.sin(ang) * (enemy.speed + 0.8);
        if(dist(enemy, wp)<14 || enemy.fakeoutTimer===0) enemy.patrolIndex = prevIndex;
      } else {
        const wp = enemy.patrol[enemy.patrolIndex % enemy.patrol.length];
        const ang = angle(enemy, wp);
        enemy.x += Math.cos(ang) * enemy.speed;
        enemy.y += Math.sin(ang) * enemy.speed;
        if(dist(enemy, wp)<12) enemy.patrolIndex = (enemy.patrolIndex+1) % enemy.patrol.length;
        // occasional random turn-about
        if(Math.random()<0.0015){ enemy.fakeoutTimer = 50; }
      }
    }

    // collision
    enemy.vx = enemy.vy = 0;
    collideCircleWalls(enemy);

    // caught? (cannot be caught while hidden)
    if(!player.hidden && dist(player, enemy) < 16){ gameOver = true; endGame(); }

    // UI
    uiKeys.textContent = `${heldKeys}`;
    uiPennants.textContent = `${heldPennants}`;
    uiStam.textContent = `${Math.round(player.stamina)}`;
    uiHidden.textContent = player.hidden ? 'Yes' : 'No';
    if(camerasDisabledTimer>0) uiCams.textContent = `Offline ${Math.ceil(camerasDisabledTimer/60)}s`;

    draw();
  }

  function endGame(){
    running=false;
    overlay.style.display='flex';
    retryBtn.style.display='inline-block';
    playBtn.style.display='none';
    titleEl.textContent = won ? "You Escaped the Principal's Office" : 'Caught by Mr. Johnson';
    msgEl.textContent = won
      ? 'Door unlocks. You step into the night. Westpine remains… hungry.'
      : 'Detention… forever. Tips: hide in lockers (E), hack terminals, respect camera sweeps, sprint in bursts, and watch for fake-outs.';
  }

  function draw(){
    // clear
    ctx.fillStyle = '#07070b';
    ctx.fillRect(0,0,W,H);

    // darkness overlay based on light level
    const dark = clamp(0.55 + (1-lightLevel)*0.6, 0, 0.95);

    // visible tiles only
    const c0 = Math.max(0, Math.floor(cam.x / TILE) - 1);
    const r0 = Math.max(0, Math.floor(cam.y / TILE) - 1);
    const c1 = Math.min(COLS-1, Math.ceil((cam.x+W) / TILE) + 1);
    const r1 = Math.min(ROWS-1, Math.ceil((cam.y+H) / TILE) + 1);

    for(let r=r0;r<=r1;r++){
      for(let c=c0;c<=c1;c++){
        const t = MAP[r][c];
        const x=c*TILE - cam.x, y=r*TILE - cam.y;
        if(t===1){
          ctx.fillStyle = '#161622';
          ctx.fillRect(x,y,TILE,TILE);
        } else if (t===10) { // Barricade
          const isBroken = barricades.find(b => b.r === r && b.c === c)?.broken;
          ctx.fillStyle = isBroken ? '#0f0f18' : '#332929';
          ctx.fillRect(x,y,TILE,TILE);
          if (!isBroken) {
            ctx.fillStyle = '#553c3c';
            ctx.fillRect(x,y, TILE, TILE/3);
            ctx.fillRect(x,y+TILE*2/3, TILE, TILE/3);
          }
        } else {
          ctx.fillStyle = '#0f0f18';
          ctx.fillRect(x,y,TILE,TILE);
          ctx.strokeStyle = 'rgba(255,255,255,0.03)';
          ctx.strokeRect(x+0.5,y+0.5,TILE-1,TILE-1);
        }
        if(t===5){ // lockers
          ctx.fillStyle = '#1b3b6f';
          ctx.fillRect(x+4,y+4,TILE-8,TILE-8);
          ctx.fillStyle = '#8bb5ff';
          ctx.fillRect(x+TILE-10,y+TILE/2-3,6,6); // handle
        }
        if(t===6){ // terminals
          ctx.fillStyle = camerasDisabledTimer>0 ? '#2a823a' : '#4062b2';
          ctx.fillRect(x+6,y+6,TILE-12,TILE-12);
          ctx.fillStyle = '#0b0b10'; ctx.fillRect(x+10,y+10,TILE-20,TILE-20);
        }
        if(t===7){ // principal door
          ctx.fillStyle = heldKeys>=keysToCollect ? '#3fa370' : '#704040';
          ctx.fillRect(x+2,y+2,TILE-4,TILE-4);
        }
        if(t===8){ // Noise Maker
          const nm = noiseMakers.find(n => n.r === r && n.c === c);
          if (nm && !nm.used) {
            ctx.fillStyle = '#e55a5a';
            ctx.beginPath();
            ctx.arc(x+TILE/2, y+TILE/2, TILE/4, 0, Math.PI*2);
            ctx.fill();
          }
        }
      }
    }

    // exit door highlight text could be added here

    // keys
    for(const k of keys){ if(k.taken) continue; const sx=k.x - cam.x, sy=k.y - cam.y; if(sx<-20||sy<-20||sx>W+20||sy>H+20) continue; ctx.fillStyle='#e8c547'; ctx.beginPath(); ctx.arc(sx,sy,6,0,Math.PI*2); ctx.fill(); }

    // pennants
    for(const p of pennantSpawnPoints){ if(p.taken) continue; const sx=p.x-cam.x, sy=p.y-cam.y; ctx.fillStyle='#6b91c9'; ctx.beginPath(); ctx.moveTo(sx,sy-8); ctx.lineTo(sx+10,sy); ctx.lineTo(sx,sy+8); ctx.closePath(); ctx.fill(); }

    // cameras fov & bodies
    for(const camObj of cameras){
      const sx=camObj.x - cam.x, sy=camObj.y - cam.y;
      // beam
      if(camerasDisabledTimer<=0){
        ctx.save();
        ctx.fillStyle = 'rgba(80,140,255,0.08)';
        drawCone(sx, sy, camObj.angle, camObj.fov, camObj.range);
        ctx.restore();
      }
      // camera body
      ctx.fillStyle = camerasDisabledTimer>0 ? '#2a823a' : '#4a73c2';
      ctx.beginPath();
      ctx.moveTo(sx+Math.cos(camObj.angle)*10, sy+Math.sin(camObj.angle)*10);
      ctx.lineTo(sx+Math.cos(camObj.angle+0.8)*10, sy+Math.sin(camObj.angle+0.8)*10);
      ctx.lineTo(sx+Math.cos(camObj.angle-0.8)*10, sy+Math.sin(camObj.angle-0.8)*10);
      ctx.closePath();
      ctx.fill();
      if(camObj.cooldown>0 && camerasDisabledTimer<=0){ // red LED while alarmed
        ctx.fillStyle = '#ff5d5d';
        ctx.beginPath(); ctx.arc(sx, sy, 3, 0, Math.PI*2); ctx.fill();
      }
    }

    // enemy FOV
    const face = enemyFacing(enemy);
    const ambient = blackoutTimer>0 ? 0.6 : (0.8 + 0.2*lightLevel);
    const eRange = enemy.baseRange * ambient;
    ctx.save();
    ctx.fillStyle = 'rgba(255,80,80,0.08)';
    drawCone(enemy.x - cam.x, enemy.y - cam.y, face, enemy.fov, eRange);
    ctx.restore();

    // player flashlight
    if(player.flashlight && !player.hidden){
      const coneAngle = player.facing;
      const coneWidth = Math.PI/5;
      const coneRange = 240;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle='rgba(180,180,200,0.12)';
      drawCone(player.x - cam.x, player.y - cam.y, coneAngle, coneWidth, coneRange);
      ctx.restore();
    }

    // apply darkness overlay
    ctx.fillStyle = `rgba(0,0,0,${dark})`;
    ctx.fillRect(0,0,W,H);

    // entities
    // player
    if(!player.hidden){
      ctx.fillStyle = '#8bb5ff';
      ctx.beginPath(); ctx.arc(player.x - cam.x, player.y - cam.y, player.r, 0, Math.PI*2); ctx.fill();
    }

    // Mr. Johnson — stylized black, bald, beard + mustache
    // head
    ctx.fillStyle = '#4b3424'; // deep brown skin tone
    ctx.beginPath(); ctx.arc(enemy.x - cam.x, enemy.y - cam.y, enemy.r+1, 0, Math.PI*2); ctx.fill();
    // beard (lower semi-circle)
    ctx.fillStyle = '#141414';
    ctx.beginPath();
    ctx.arc(enemy.x - cam.x, enemy.y - cam.y + 2, enemy.r-2, Math.PI*0.15, Math.PI-0.15);
    ctx.lineTo(enemy.x - cam.x, enemy.y - cam.y + 3);
    ctx.closePath(); ctx.fill();
    // mustache (thin arc)
    ctx.strokeStyle = '#0d0d0d';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(enemy.x - cam.x, enemy.y - cam.y + 1, enemy.r-6, Math.PI*0.05, Math.PI-0.05);
    ctx.stroke();

    // alert marker
    if(enemy.alert){
      ctx.fillStyle = '#ff5d5d';
      ctx.beginPath(); ctx.arc(enemy.x - cam.x, enemy.y - cam.y - enemy.r - 10, 4, 0, Math.PI*2); ctx.fill();
    }
  }

  function drawCone(x,y,angleCenter, angleWidth, radius){
    ctx.beginPath();
    ctx.moveTo(x,y);
    ctx.arc(x,y, radius, angleCenter - angleWidth/2, angleCenter + angleWidth/2);
    ctx.closePath();
    ctx.fill();
  }

  // Kick off the loop immediately; it will keep running even while paused
  requestAnimationFrame(update);
  </script>
</body>
</html>
