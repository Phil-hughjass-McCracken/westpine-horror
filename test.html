<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Westpine Night — 4.2</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0a0a0f; color:#e6e6f0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
    #ui { position: fixed; inset: 0 0 auto 0; display:flex; gap:12px; align-items:center; padding:10px 14px; background: linear-gradient(180deg, rgba(10,10,15,.9), rgba(10,10,15,.25)); backdrop-filter: blur(4px); z-index: 10; }
    #ui .pill { padding:4px 10px; border-radius:14px; background:#1b1b25; border:1px solid #2b2b38; box-shadow: inset 0 0 0 1px rgba(255,255,255,.03); font-size: 14px; }
    #ui .right { margin-left:auto; opacity:.95 }
    #ui .inv { display:flex; gap:8px; align-items:center; }
    #game { display:block; margin:0 auto; image-rendering: pixelated; }
    #overlay { position: fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.8); z-index: 20; }
    #overlay .card { background:#121219; border:1px solid #2b2b38; border-radius:16px; padding:20px; width:min(680px, 92vw); text-align:center; box-shadow: 0 10px 30px rgba(0,0,0,.6); }
    #overlay h1 { margin:0 0 8px; font-size:28px; }
    #overlay p { margin:8px 0 16px; line-height:1.5 }
    #overlay button { background:#2b2bff; border:0; color:white; padding:10px 16px; border-radius:10px; cursor:pointer; font-weight:600; }
    #overlay button.secondary { background:#1b1b25; border:1px solid #2b2b38; margin-left:8px; }
    #alert { position: fixed; right:12px; bottom:12px; background:#3a0d0d; color:#ffb3b3; padding:8px 12px; border:1px solid #5c1717; border-radius:10px; display:none; font-weight:700; z-index: 15; }
    #changelog-popup { position:fixed; inset:0; background:rgba(0,0,0,.85); display:none; justify-content:center; align-items:center; z-index: 30; }
    #changelog-content { background:#121219; border:1px solid #2b2b38; border-radius:16px; padding:20px; width:min(680px, 92vw); max-height:80vh; overflow-y:auto; text-align:left; box-shadow: 0 10px 30px rgba(0,0,0,.6); }
    #changelog-content h2 { margin-top:0; }
    #changelog-content ul { padding-left:20px; }
    #changelog-content li { margin-bottom:8px; }
    #code-prompt { position:fixed; inset:0; background:rgba(0,0,0,.85); display:none; justify-content:center; align-items:center; z-index: 40; }
    #code-card { background:#121219; border:1px solid #2b2b38; border-radius:16px; padding:20px; text-align:center; box-shadow: 0 10px 30px rgba(0,0,0,.6); }
    #code-input { width:120px; text-align:center; font-size:24px; letter-spacing:4px; padding:8px; background:#0b0b10; border:1px solid #2b2b38; color:#e6e6f0; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="pill">WASD/Arrows: Move</div>
    <div class="pill">Shift: Sprint (noise!)</div>
    <div class="pill">F: Flashlight</div>
    <div class="pill">E: Interact/Hide/Open Door</div>
    <div class="pill right inv">Keys: <span id="keys">0</span>/8 · Stamina: <span id="stamina">100</span>% · Hidden: <span id="hidden">No</span> · Cams: <span id="cams">Online</span></div>
  </div>
  <canvas id="game" width="960" height="576"></canvas>
  <div id="overlay">
    <div class="card">
      <h1 id="title">Westpine Night 4.2</h1>
      <p id="message">New: Find 8 keys hidden in code-locked classrooms. Find codes on chalkboards to open doors. Hack camera terminals and hide from Mr. Johnson to escape.</p>
      <div>
        <button id="play">Play</button>
        <button id="retry" class="secondary" style="display:none">Retry</button>
        <button id="changelog-btn" class="secondary">Changelog</button>
      </div>
    </div>
  </div>
  <div id="alert">ALERT: Camera spotted you!</div>
  
  <div id="changelog-popup">
    <div id="changelog-content">
      <h2>Changelog</h2>
      <ul>
        <li>**v4.2 (August 2025)**
          <ul>
            <li>**Fix:** Corrected the main "Play" and "Retry" buttons to function correctly.</li>
          </ul>
        </li>
        <li>**v4.1 (August 2025)**
          <ul>
            <li>**Bug Fix:** Corrected the issue where the "Play" button didn't start the game.</li>
            <li>**UI Fix:** The keys collected counter in the UI is now working correctly.</li>
            <li>**Minor Fixes:** Corrected a few other small bugs and made gameplay more stable.</li>
          </ul>
        </li>
        <li>**v4.0 (August 2025)**
          <ul>
            <li>**The Mission:** The goal is to collect **8 keys** and escape through the front door.</li>
            <li>**Code Puzzles:** Classrooms are now locked. You must find a two-digit code on a **chalkboard** in another room to unlock them.</li>
            <li>**Interactive Doors:** Doors can now be opened and closed with the **'E' key**.</li>
            <li>**Light Sources:** Added specific points of light to the map, creating brightly lit and dark areas.</li>
            <li>**Removed:** The inventory, collectibles, and barricades have all been removed.</li>
          </ul>
        </li>
      </ul>
      <button id="close-changelog" style="display:block; margin:20px auto 0;">Close</button>
    </div>
  </div>

  <div id="code-prompt">
    <div id="code-card">
      <h2>Enter Code</h2>
      <input type="number" id="code-input" maxlength="2" placeholder="__" />
      <div style="margin-top:10px;">
        <button id="submit-code">Unlock</button>
        <button id="cancel-code" class="secondary">Cancel</button>
      </div>
    </div>
  </div>

  <script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  const uiKeys = document.getElementById('keys');
  const uiStam = document.getElementById('stamina');
  const uiHidden = document.getElementById('hidden');
  const uiCams = document.getElementById('cams');
  const overlay = document.getElementById('overlay');
  const titleEl = document.getElementById('title');
  const msgEl = document.getElementById('message');
  const playBtn = document.getElementById('play');
  const retryBtn = document.getElementById('retry');
  const changelogBtn = document.getElementById('changelog-btn');
  const changelogPopup = document.getElementById('changelog-popup');
  const closeChangelogBtn = document.getElementById('close-changelog');
  const alertEl = document.getElementById('alert');
  const codePrompt = document.getElementById('code-prompt');
  const codeInput = document.getElementById('code-input');
  const submitCodeBtn = document.getElementById('submit-code');
  const cancelCodeBtn = document.getElementById('cancel-code');

  const TILE = 32;

  // Map legend: 1=wall, 0=floor, 2=spawn, 3=door, 4=key, 5=locker, 6=camera terminal, 7=exit door, 8=noise maker, 9=chalkboard, 11=light source
  const MAP_BASE = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,0,0,0,0,0,0,3,0,5,5,0,0,0,0,3,0,0,0,0,3,0,0,0,0,0,0,0,0,3,0,0,0,0,0,6,0,0,1],
    [1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,1,1,0,5,0,0,0,1,1,0,0,5,0,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,5,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,5,1,0,0,1],
    [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,5,0,0,0,0,0,1,0,0,0,0,5,0,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,6,1,0,0,1],
    [1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,1,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,5,1,0,0,1],
    [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
    [1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,5,1,0,0,1],
    [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1],
    [1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,5,1,0,0,1],
    [1,0,1,1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  ];
  let MAP = JSON.parse(JSON.stringify(MAP_BASE));

  const ROWS = MAP.length;
  const COLS = MAP[0].length;

  const keysToCollect = 8;
  let keysCollected = 0;

  function findTile(n){
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(MAP[r][c]===n) return {x:c*TILE+TILE/2, y:r*TILE+TILE/2};
    return {x:TILE*2, y:TILE*2};
  }

  function findAllTiles(n){ const arr=[]; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(MAP[r][c]===n) arr.push({x:c*TILE+TILE/2, y:r*TILE+TILE/2, r, c}); return arr; }

  const spawn = findTile(2);
  const exitDoor = findAllTiles(7)[0];

  // Entities
  const player = { x: spawn.x, y: spawn.y, r: 12, speed: 2.1, sprint: 3.3, vx:0, vy:0, stamina: 100, flashlight:false, facing:0, hidden:false };
  const enemy = { x: spawn.x+200, y: spawn.y+40, r:14, speed:1.85, fov: Math.PI/4.5, baseRange: 260, alert:false, target:null, patrol:[], patrolIndex:0, cooldown:0, fakeoutTimer:0 };

  // Camera scroll
  const cam = { x: 0, y: 0 };

  // Build patrol waypoints roughly around main halls
  enemy.patrol = [
    {x: TILE*8,  y: TILE*3},
    {x: TILE*8,  y: TILE*16},
    {x: TILE*22, y: TILE*16},
    {x: TILE*34, y: TILE*16},
    {x: TILE*34, y: TILE*4},
    {x: TILE*22, y: TILE*4},
  ];

  // Map elements that need state
  let doors = [];
  let chalkboards = [];
  let keys = [];
  let lockers = [];
  let terminals = [];
  let lightSources = [];
  let noiseMakers = [];
  let cameras = [];

  let codePromptActive = false;
  let activeDoor = null;

  // Systems
  let running = false;
  let gameOver = false;
  let won = false;
  let camAlertTimer = 0;
  let camerasDisabledTimer = 0;
  let lightLevel = 1;
  let flickerTimer = 0;
  let blackoutTimer = 0;

  const HEAR_RANGE = 280;

  const input = { up:false, down:false, left:false, right:false, sprint:false, interact:false };
  onkeydown = e => {
    if(gameOver || won) return;
    if(e.key==='ArrowUp'||e.key==='w') input.up=true;
    if(e.key==='ArrowDown'||e.key==='s') input.down=true;
    if(e.key==='ArrowLeft'||e.key==='a') input.left=true;
    if(e.key==='ArrowRight'||e.key==='d') input.right=true;
    if(e.key==='Shift') input.sprint=true;
    if(e.key==='f' || e.key==='F') player.flashlight = !player.flashlight;
    if(e.key==='e' || e.key==='E') input.interact = true;
  }
  onkeyup = e => {
    if(gameOver || won) return;
    if(e.key==='ArrowUp'||e.key==='w') input.up=false;
    if(e.key==='ArrowDown'||e.key==='s') input.down=false;
    if(e.key==='ArrowLeft'||e.key==='a') input.left=false;
    if(e.key==='ArrowRight'||e.key==='d') input.right=false;
    if(e.key==='e' || e.key==='E') input.interact = false;
  }

  function tileAt(x,y){
    const c = Math.floor(x / TILE), r = Math.floor(y / TILE);
    if(r<0||r>=ROWS||c<0||c>=COLS) return 1;
    return MAP[r][c];
  }

  function collideCircleWalls(obj){
    if(tileAt(obj.x+obj.vx+Math.sign(obj.vx)*obj.r, obj.y)===1) obj.vx = 0;
    if(tileAt(obj.x, obj.y+obj.vy+Math.sign(obj.vy)*obj.r)===1) obj.vy = 0;
    if(tileAt(obj.x+Math.sign(obj.vx)*obj.r, obj.y+Math.sign(obj.vy)*obj.r)===1){ obj.vx=0; obj.vy=0; }
  }

  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function angle(a,b){ return Math.atan2(b.y-a.y, b.x-a.x); }
  function clamp(v,mi,ma){ return Math.max(mi, Math.min(ma, v)); }

  function canSeeCone(from,to, angleCenter, fov, maxDist){
    const ang = angle({x:from.x,y:from.y},to);
    const withinCone = Math.abs(normalizeAngle(ang - angleCenter)) <= fov/2;
    if(!withinCone) return false;
    const d = dist(from, to); if(d>maxDist) return false;
    const steps = Math.ceil(d/6);
    for(let i=1;i<=steps;i++){
      const px = from.x + (to.x-from.x)*(i/steps);
      const py = from.y + (to.y-from.y)*(i/steps);
      const t = tileAt(px,py);
      if(t===1) return false;
      const door = doors.find(d => d.r === Math.floor(py/TILE) && d.c === Math.floor(px/TILE));
      if(door && !door.open) return false;
    }
    return true;
  }

  function canSeeEnemy(){
    const ambient = blackoutTimer>0 ? 0.6 : (0.8 + 0.2*lightLevel);
    const baseRange = enemy.baseRange * ambient * (player.flashlight ? 1.15 : 1.0);
    const facing = enemyFacing(enemy);
    return canSeeCone(enemy, player, facing, enemy.fov, baseRange);
  }

  function normalizeAngle(a){ while(a>Math.PI) a-=2*Math.PI; while(a<-Math.PI) a+=2*Math.PI; return a; }
  function enemyFacing(e){
    if(e.target){ return angle(e, e.target); }
    const next = e.patrol[(e.patrolIndex)%e.patrol.length];
    return angle(e,next);
  }

  function nearThing(list, radius=24){ for(const p of list){ if(dist(player,p)<radius) return p; } return null; }
  function nearLocker(){ return nearThing(lockers, 26); }
  function nearTerminal(){ return nearThing(terminals, 28); }
  function nearNoiseMaker(){ return nearThing(noiseMakers, 28); }
  function nearDoor(){ return nearThing(doors, 28); }
  function nearExitDoor(){ return dist(player, exitDoor)<28; }
  function nearKey(){ return nearThing(keys, 20); }

  function tryInteract(){
    if(player.hidden){ player.hidden=false; player.flashlight=false; uiHidden.textContent='No'; return; }
    
    // Doors
    const door = nearDoor();
    if(door){
      if(door.locked){
        if(!codePromptActive){
          codePromptActive=true;
          activeDoor = door;
          codePrompt.style.display = 'flex';
          codeInput.value = '';
          codeInput.focus();
        }
      } else {
        door.open = !door.open;
        if(door.open) {
          MAP[door.r][door.c] = 0; // change door to floor for collision
        } else {
          MAP[door.r][door.c] = 3;
        }
      }
      return;
    }

    // Terminals
    const term = nearTerminal();
    if(term){ camerasDisabledTimer = 60*30; uiCams.textContent = 'Offline'; return; }

    // Lockers
    const locker = nearLocker();
    if(locker){ player.hidden=true; player.vx=player.vy=0; player.flashlight=false; uiHidden.textContent='Yes'; return; }

    // Noise makers
    const nm = nearNoiseMaker();
    if(nm && !nm.used){
      nm.used = true;
      enemy.alert = true;
      enemy.target = {x: nm.x, y: nm.y};
      enemy.cooldown = 360;
      return;
    }

    const key = nearKey();
    if(key && !key.taken){
      key.taken = true;
      keysCollected++;
      return;
    }

    if(keysCollected >= keysToCollect && nearExitDoor()){ won=true; endGame(); return; }
  }

  function setupMapElements(){
    MAP = JSON.parse(JSON.stringify(MAP_BASE));
    doors = [];
    chalkboards = [];
    keys = [];
    lockers = [];
    terminals = [];
    lightSources = [];
    noiseMakers = [];
    cameras = [];

    // Find all dynamic elements
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        const tile = MAP[r][c];
        const obj = {x: c*TILE+TILE/2, y: r*TILE+TILE/2, r, c};
        if(tile === 3){
          obj.open = false;
          obj.locked = true;
          obj.code = Math.floor(10 + Math.random()*90); // two-digit code
          doors.push(obj);
        } else if(tile === 5){
          lockers.push(obj);
        } else if(tile === 6){
          terminals.push(obj);
        } else if(tile === 8){
          obj.used = false;
          noiseMakers.push(obj);
        } else if (tile === 4) {
          obj.taken = false;
          keys.push(obj);
        }
      }
    }
    const codeLocations = findAllTiles(9).slice(0, doors.length);
    for(let i=0; i<doors.length; i++){
      const door = doors[i];
      const chalkboard = codeLocations[i];
      chalkboard.code = door.code;
      chalkboards.push(chalkboard);
    }
    
    // Static lights
    lightSources.push({x: TILE*25, y: TILE*4, radius: 200});
    lightSources.push({x: TILE*12, y: TILE*18, radius: 240});
    lightSources.push({x: TILE*35, y: TILE*15, radius: 220});
    lightSources.push({x: TILE*5, y: TILE*10, radius: 180});
    lightSources.push({x: TILE*20, y: TILE*20, radius: 200});
  }

  function reset(){
    setupMapElements();
    player.x = spawn.x; player.y = spawn.y; player.stamina=100; player.flashlight=false; player.hidden=false;
    keysCollected = 0;
    
    enemy.x = spawn.x+200; enemy.y = spawn.y+40; enemy.alert=false; enemy.target=null; enemy.patrolIndex=0; enemy.cooldown=0; enemy.fakeoutTimer=0;
    camAlertTimer = 0; alertEl.style.display='none';
    camerasDisabledTimer = 0; uiCams.textContent='Online';
    lightLevel = 1; flickerTimer=0; blackoutTimer=0;
    running = true; gameOver=false; won=false;
    overlay.style.display='none';
    retryBtn.style.display='none';
    playBtn.style.display='inline-block';
  }

  playBtn.addEventListener('click', () => { reset(); });
  retryBtn.addEventListener('click', () => { reset(); });
  changelogBtn.addEventListener('click', () => { changelogPopup.style.display = 'flex'; });
  closeChangelogBtn.addEventListener('click', () => { changelogPopup.style.display = 'none'; });

  // Code prompt interaction
  submitCodeBtn.addEventListener('click', () => {
    const enteredCode = parseInt(codeInput.value, 10);
    if(activeDoor && enteredCode === activeDoor.code){
      activeDoor.locked = false;
      activeDoor.open = true;
      MAP[activeDoor.r][activeDoor.c] = 0;
    }
    codePromptActive = false;
    codePrompt.style.display = 'none';
  });
  cancelCodeBtn.addEventListener('click', () => {
    codePromptActive = false;
    codePrompt.style.display = 'none';
  });
  codeInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      submitCodeBtn.click();
    }
  });

  // Start menu shown initially
  overlay.style.display='flex';

  function update(){
    requestAnimationFrame(update);
    cam.x = clamp(player.x - W/2, 0, COLS*TILE - W);
    cam.y = clamp(player.y - H/2, 0, ROWS*TILE - H);

    if(!running){ draw(); return; }

    // --- Lighting effects ---
    if(blackoutTimer>0){ blackoutTimer--; lightLevel = 0.25; }
    else {
      if(flickerTimer>0){ flickerTimer--; lightLevel = 0.7 + Math.random()*0.2; }
      else { lightLevel = 1; if(Math.random()<0.001) flickerTimer = 40; if(Math.random()<0.0003) blackoutTimer = 180; }
    }

    if(input.interact){ tryInteract(); input.interact=false; }

    if(!player.hidden){
      const spd = (input.sprint && player.stamina>0) ? player.sprint : player.speed;
      player.vx = (input.right - input.left) * spd;
      player.vy = (input.down - input.up) * spd;
      if(player.vx && player.vy){ player.vx *= 0.7071; player.vy *= 0.7071; }
      const moving = (player.vx||player.vy);
      if(input.sprint && moving) player.stamina = Math.max(0, player.stamina - 0.25);
      else player.stamina = Math.min(100, player.stamina + 0.15);
      collideCircleWalls(player);
      player.x += player.vx; player.y += player.vy;
      if(moving) player.facing = Math.atan2(player.vy, player.vx);
      if(input.sprint && moving){
        const d = dist(player, enemy);
        if(d < HEAR_RANGE){ enemy.alert = true; enemy.target = {x:player.x, y:player.y}; enemy.cooldown = 180; }
      }
    } else {
      player.stamina = Math.min(100, player.stamina + 0.4);
    }

    // --- Cameras ---
    if(camerasDisabledTimer>0){ camerasDisabledTimer--; if(camerasDisabledTimer===0) uiCams.textContent='Online'; }
    for(const camObj of cameras){
      camObj.angle += camObj.speed * camObj.dir;
      if(camObj.angle>camObj.max){ camObj.angle=camObj.max; camObj.dir*=-1; }
      if(camObj.angle<camObj.min){ camObj.angle=camObj.min; camObj.dir*=-1; }
      if(player.hidden) continue;
      if(camerasDisabledTimer>0) continue;
      if(canSeeCone(camObj, player, camObj.angle, camObj.fov, camObj.range)){
        camObj.cooldown = 180;
        camAlertTimer = 60;
        alertEl.style.display='block';
        enemy.alert = true;
        enemy.target = {x: player.x, y: player.y};
        enemy.cooldown = 300;
      } else if(camObj.cooldown>0){ camObj.cooldown--; }
    }
    if(camAlertTimer>0){ camAlertTimer--; if(camAlertTimer===0) alertEl.style.display='none'; }

    // --- Enemy AI ---
    const seen = !player.hidden && canSeeEnemy();
    if(!enemy.alert && !player.hidden){
      const toPlayer = angle(enemy, player);
      const face = enemyFacing(enemy);
      const behind = Math.abs(normalizeAngle(toPlayer - face)) > Math.PI*0.7;
      if(behind && dist(player, enemy) < 140){ if(enemy.fakeoutTimer<=0) enemy.fakeoutTimer = 60; }
    }

    if(seen){ enemy.alert = true; enemy.target = {x:player.x, y:player.y}; enemy.cooldown = 240; enemy.fakeoutTimer = 0; }
    else { if(enemy.cooldown>0) enemy.cooldown--; else enemy.alert=false; }

    if(enemy.alert){
      const ang = angle(enemy, enemy.target);
      const spd = enemy.speed + 0.4;
      enemy.x += Math.cos(ang) * spd;
      enemy.y += Math.sin(ang) * spd;
      if(dist(enemy, enemy.target)<12) enemy.alert=false;
    } else {
      if(enemy.fakeoutTimer>0){
        enemy.fakeoutTimer--;
        const prevIndex = (enemy.patrolIndex - 1 + enemy.patrol.length) % enemy.patrol.length;
        const wp = enemy.patrol[prevIndex];
        const ang = angle(enemy, wp);
        enemy.x += Math.cos(ang) * (enemy.speed + 0.8);
        enemy.y += Math.sin(ang) * (enemy.speed + 0.8);
        if(dist(enemy, wp)<14 || enemy.fakeoutTimer===0) enemy.patrolIndex = prevIndex;
      } else {
        const wp = enemy.patrol[enemy.patrolIndex % enemy.patrol.length];
        const ang = angle(enemy, wp);
        enemy.x += Math.cos(ang) * enemy.speed;
        enemy.y += Math.sin(ang) * enemy.speed;
        if(dist(enemy, wp)<12) enemy.patrolIndex = (enemy.patrolIndex+1) % enemy.patrol.length;
        if(Math.random()<0.0015){ enemy.fakeoutTimer = 50; }
      }
    }

    enemy.vx = enemy.vy = 0;
    collideCircleWalls(enemy);
    if(!player.hidden && dist(player, enemy) < 16){ gameOver = true; endGame(); }

    updateUI();
    draw();
  }

  function updateUI() {
    uiKeys.textContent = keysCollected;
    uiStam.textContent = `${Math.round(player.stamina)}`;
    uiHidden.textContent = player.hidden ? 'Yes' : 'No';
    if(camerasDisabledTimer>0) uiCams.textContent = `Offline ${Math.ceil(camerasDisabledTimer/60)}s`;
  }

  function endGame(){
    running=false;
    overlay.style.display='flex';
    retryBtn.style.display='inline-block';
    playBtn.style.display='none';
    titleEl.textContent = won ? "You Escaped Westpine Academy" : 'Caught by Mr. Johnson';
    msgEl.textContent = won
      ? 'You unlock the front door and step outside. The cool night air is a welcome relief.'
      : 'Detention… forever. Tips: hide in lockers (E), hack terminals, respect camera sweeps, sprint in bursts, and watch for fake-outs.';
  }

  function draw(){
    ctx.fillStyle = '#07070b';
    ctx.fillRect(0,0,W,H);

    const dark = clamp(0.55 + (1-lightLevel)*0.6, 0, 0.95);
    const c0 = Math.max(0, Math.floor(cam.x / TILE) - 1);
    const r0 = Math.max(0, Math.floor(cam.y / TILE) - 1);
    const c1 = Math.min(COLS-1, Math.ceil((cam.x+W) / TILE) + 1);
    const r1 = Math.min(ROWS-1, Math.ceil((cam.y+H) / TILE) + 1);

    for(let r=r0;r<=r1;r++){
      for(let c=c0;c<=c1;c++){
        const t = MAP[r][c];
        const x=c*TILE - cam.x, y=r*TILE - cam.y;
        if(t===1){
          ctx.fillStyle = '#161622';
          ctx.fillRect(x,y,TILE,TILE);
        } else {
          ctx.fillStyle = '#0f0f18';
          ctx.fillRect(x,y,TILE,TILE);
          ctx.strokeStyle = 'rgba(255,255,255,0.03)';
          ctx.strokeRect(x+0.5,y+0.5,TILE-1,TILE-1);
        }
        if(t===3){
          const door = doors.find(d => d.r === r && d.c === c);
          if(!door.open){
            ctx.fillStyle = door.locked ? '#404070' : '#4a73c2';
            ctx.fillRect(x,y,TILE,TILE);
          }
        }
        if(t===5){
          ctx.fillStyle = '#1b3b6f';
          ctx.fillRect(x+4,y+4,TILE-8,TILE-8);
          ctx.fillStyle = '#8bb5ff';
          ctx.fillRect(x+TILE-10,y+TILE/2-3,6,6);
        }
        if(t===6){
          ctx.fillStyle = camerasDisabledTimer>0 ? '#2a823a' : '#4062b2';
          ctx.fillRect(x+6,y+6,TILE-12,TILE-12);
          ctx.fillStyle = '#0b0b10'; ctx.fillRect(x+10,y+10,TILE-20,TILE-20);
        }
        if(t===7){
          ctx.fillStyle = keysCollected>=keysToCollect ? '#3fa370' : '#704040';
          ctx.fillRect(x+2,y+2,TILE-4,TILE-4);
        }
        if(t===8){
          const nm = noiseMakers.find(n => n.r === r && n.c === c);
          if (nm && !nm.used) {
            ctx.fillStyle = '#e55a5a';
            ctx.beginPath();
            ctx.arc(x+TILE/2, y+TILE/2, TILE/4, 0, Math.PI*2);
            ctx.fill();
          }
        }
        if(t===9){
          ctx.fillStyle = '#222233';
          ctx.fillRect(x+4,y+4,TILE-8,TILE-8);
          const cb = chalkboards.find(b => b.r === r && b.c === c);
          if(cb){
            ctx.fillStyle = '#b3e8b3';
            ctx.font = '10px monospace';
            ctx.fillText(`Code: ${cb.code}`, x+8, y+16);
          }
        }
      }
    }

    // Keys
    for(const k of keys){ if(k.taken) continue; const sx=k.x - cam.x, sy=k.y - cam.y; if(sx<-20||sy<-20||sx>W+20||sy>H+20) continue; ctx.fillStyle='#e8c547'; ctx.beginPath(); ctx.arc(sx,sy,6,0,Math.PI*2); ctx.fill(); }

    // Cameras fov & bodies
    for(const camObj of cameras){
      const sx=camObj.x - cam.x, sy=camObj.y - cam.y;
      if(camerasDisabledTimer<=0){
        ctx.save();
        ctx.fillStyle = 'rgba(80,140,255,0.08)';
        drawCone(sx, sy, camObj.angle, camObj.fov, camObj.range);
        ctx.restore();
      }
      ctx.fillStyle = camerasDisabledTimer>0 ? '#2a823a' : '#4a73c2';
      ctx.beginPath();
      ctx.moveTo(sx+Math.cos(camObj.angle)*10, sy+Math.sin(camObj.angle)*10);
      ctx.lineTo(sx+Math.cos(camObj.angle+0.8)*10, sy+Math.sin(camObj.angle+0.8)*10);
      ctx.lineTo(sx+Math.cos(camObj.angle-0.8)*10, sy+Math.sin(camObj.angle-0.8)*10);
      ctx.closePath();
      ctx.fill();
      if(camObj.cooldown>0 && camerasDisabledTimer<=0){
        ctx.fillStyle = '#ff5d5d';
        ctx.beginPath(); ctx.arc(sx, sy, 3, 0, Math.PI*2); ctx.fill();
      }
    }

    // Light sources
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for(const light of lightSources){
      const sx=light.x - cam.x, sy=light.y - cam.y;
      const lightRange = light.radius + Math.sin(Date.now()/500)*5;
      const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, lightRange);
      gradient.addColorStop(0, 'rgba(255, 255, 200, 0.2)');
      gradient.addColorStop(1, 'rgba(255, 255, 200, 0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(sx, sy, lightRange, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();

    // enemy FOV
    const face = enemyFacing(enemy);
    const ambient = blackoutTimer>0 ? 0.6 : (0.8 + 0.2*lightLevel);
    const eRange = enemy.baseRange * ambient;
    ctx.save();
    ctx.fillStyle = 'rgba(255,80,80,0.08)';
    drawCone(enemy.x - cam.x, enemy.y - cam.y, face, enemy.fov, eRange);
    ctx.restore();

    // player flashlight
    if(player.flashlight && !player.hidden){
      const coneAngle = player.facing;
      const coneWidth = Math.PI/5;
      const coneRange = 240;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle='rgba(180,180,200,0.12)';
      drawCone(player.x - cam.x, player.y - cam.y, coneAngle, coneWidth, coneRange);
      ctx.restore();
    }

    ctx.fillStyle = `rgba(0,0,0,${dark})`;
    ctx.fillRect(0,0,W,H);

    // entities
    if(!player.hidden){
      ctx.fillStyle = '#8bb5ff';
      ctx.beginPath(); ctx.arc(player.x - cam.x, player.y - cam.y, player.r, 0, Math.PI*2); ctx.fill();
    }

    ctx.fillStyle = '#4b3424';
    ctx.beginPath(); ctx.arc(enemy.x - cam.x, enemy.y - cam.y, enemy.r+1, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#141414';
    ctx.beginPath();
    ctx.arc(enemy.x - cam.x, enemy.y - cam.y + 2, enemy.r-2, Math.PI*0.15, Math.PI-0.15);
    ctx.lineTo(enemy.x - cam.x, enemy.y - cam.y + 3);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle = '#0d0d0d';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(enemy.x - cam.x, enemy.y - cam.y + 1, enemy.r-6, Math.PI*0.05, Math.PI-0.05);
    ctx.stroke();

    if(enemy.alert){
      ctx.fillStyle = '#ff5d5d';
      ctx.beginPath(); ctx.arc(enemy.x - cam.x, enemy.y - cam.y - enemy.r - 10, 4, 0, Math.PI*2); ctx.fill();
    }
  }

  function drawCone(x,y,angleCenter, angleWidth, radius){
    ctx.beginPath();
    ctx.moveTo(x,y);
    ctx.arc(x,y, radius, angleCenter - angleWidth/2, angleCenter + angleWidth/2);
    ctx.closePath();
    ctx.fill();
  }

  requestAnimationFrame(update);
  </script>
</body>
</html>
