<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Westpine Night — Crawlspaces & Weather</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0a0a0f; color:#e6e6f0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial; }
    #ui { position: fixed; inset: 0 0 auto 0; display:flex; gap:12px; align-items:center; padding:10px 14px; background: linear-gradient(180deg, rgba(10,10,15,.9), rgba(10,10,15,.25)); backdrop-filter: blur(4px); z-index: 10; }
    #ui .pill { padding:4px 10px; border-radius:14px; background:#1b1b25; border:1px solid #2b2b38; box-shadow: inset 0 0 0 1px rgba(255,255,255,.03); font-size: 13px; white-space: nowrap;}
    #ui .right { margin-left:auto; opacity:.95 }
    #ui .inv { display:flex; gap:8px; align-items:center; }
    #game { display:block; margin:0 auto; image-rendering: pixelated; touch-action:none; }
    #overlay { position: fixed; inset:0; display:none; align-items:center; justify-content:center; background: rgba(0,0,0,.8); z-index: 20; }
    #overlay .card { background:#121219; border:1px solid #2b2b38; border-radius:16px; padding:20px; width:min(760px, 92vw); text-align:center; box-shadow: 0 10px 30px rgba(0,0,0,.6); }
    #overlay h1 { margin:0 0 8px; font-size:28px; }
    #overlay p { margin:8px 0 16px; line-height:1.5 }
    #overlay button { background:#2b2bff; border:0; color:white; padding:10px 16px; border-radius:10px; cursor:pointer; font-weight:600; }
    #overlay button.secondary { background:#1b1b25; border:1px solid #2b2b38; margin-left:8px; }
    #alert { position: fixed; right:12px; bottom:12px; background:#3a0d0d; color:#ffb3b3; padding:8px 12px; border:1px solid #5c1717; border-radius:10px; display:none; font-weight:700; z-index: 15; }
    /* Mobile controls */
    #controls { position: fixed; inset:auto 0 0 0; display:flex; justify-content:space-between; gap:10px; padding:14px; z-index:12; pointer-events:none; }
    .stick { width:120px; height:120px; border-radius:50%; background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.07); position:relative; touch-action:none; pointer-events:auto; }
    .nub { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:54px; height:54px; border-radius:50%; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.2); }
    .btns { display:flex; gap:10px; align-items:flex-end; pointer-events:auto; }
    .btn { min-width:72px; min-height:52px; padding:8px 12px; border-radius:12px; font-weight:700; border:1px solid rgba(255,255,255,.12); background:rgba(20,20,28,.55); color:#e6e6f0; }
    .btn:active { transform:translateY(1px); }
    @media (min-width: 900px) {
      .stick { width:140px; height:140px; }
      .nub { width:60px; height:60px; }
      .btn { min-width:88px; min-height:56px; font-size:15px; }
    }
  </style>
</head>
<body>
  <div id="ui">
    <div class="pill">WASD/Arrows: Move</div>
    <div class="pill">Shift / Hold Sprint</div>
    <div class="pill">F / Flashlight</div>
    <div class="pill">E / Interact (Doors/Lockers/Terminals/Crawl)</div>
    <div class="pill right inv">Fragments: <span id="keys">0</span>/8 · Master: <span id="master">No</span> · Stamina: <span id="stamina">100</span>% · Hidden: <span id="hidden">No</span> · Cams: <span id="cams">Online</span> · Weather: <span id="weather">—</span></div>
  </div>

  <canvas id="game" width="960" height="576"></canvas>

  <div id="overlay">
    <div class="card">
      <h1 id="title">Westpine Night</h1>
      <p id="message">
        New: classrooms with doors, crawlspaces (vents), randomized key fragments, outdoor exit, mobile controls, and weather (rain/fog/storm).<br/>
        Collect <b>8 fragments</b> hidden in <b>classrooms</b>. They auto-forge a <b>MASTER KEY</b> that opens the <b>courtyard gate</b>. Hide in <b>lockers</b>, hack <b>camera terminals</b>, and avoid Mr. Johnson.
      </p>
      <div>
        <button id="play">Play</button>
        <button id="retry" class="secondary" style="display:none">Retry</button>
      </div>
    </div>
  </div>

  <div id="alert">ALERT: Camera spotted you!</div>

  <!-- Mobile controls -->
  <div id="controls">
    <div class="stick" id="stick"><div class="nub" id="nub"></div></div>
    <div class="btns">
      <button class="btn" id="btnInteract">Interact</button>
      <button class="btn" id="btnFlash">Flash</button>
      <button class="btn" id="btnSprint">Sprint</button>
    </div>
  </div>

<script>
// ===== Core Setup =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

const uiKeys = document.getElementById('keys');
const uiMaster = document.getElementById('master');
const uiStam = document.getElementById('stamina');
const uiHidden = document.getElementById('hidden');
const uiCams = document.getElementById('cams');
const uiWeather = document.getElementById('weather');
const overlay = document.getElementById('overlay');
const titleEl = document.getElementById('title');
const msgEl = document.getElementById('message');
const playBtn = document.getElementById('play');
const retryBtn = document.getElementById('retry');
const alertEl = document.getElementById('alert');

// Mobile controls
const stick = document.getElementById('stick');
const nub = document.getElementById('nub');
const btnInteract = document.getElementById('btnInteract');
const btnFlash = document.getElementById('btnFlash');
const btnSprint = document.getElementById('btnSprint');

const TILE = 32;

// Legend
// 1=wall, 0=floor, 2=spawn, 3=door (closed), 4=key spawn marker (classrooms interior), 5=locker,
// 6=terminal, 7=old office marker (unused), 8=crawlspace floor (can move through hidden), 9=exit gate
// 11=door frame (always floor; just visual), 12=desk, 13=window (visual), 14=hall marker (visual)
const MAP = [
  // 40x24, halls around with classrooms branching; exit gate on bottom-left courtyard
  // 0           5         10         15         20         25         30         35         40
  //            |          |          |          |          |          |          |          |
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,2,14,14,14,14,14,14,1,0,3,0,12,12,0,0,1,0,0,0,0,1,12,12,0,4,0,0,0,0,1,0,0,0,0,0,6,0,0,1],
  [1,0,14,1,1,14,14,14,1,0,11,0,12,12,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,0,0,1,0,0,1],
  [1,0,14,1,1,14,5,14,0,0,3,0,12,12,0,0,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
  [1,0,14,14,14,14,14,14,1,0,11,0,0,0,0,0,1,0,0,5,0,1,0,1,0,0,1,0,0,0,1,0,0,0,12,5,1,0,0,1],
  [1,0,1,1,14,1,1,14,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,0,1,1,14,14,1,0,1,1,0,0,1,0,0,1],
  [1,0,14,14,14,14,14,14,0,0,0,0,0,0,0,0,0,0,14,14,14,14,14,14,0,4,0,0,0,0,0,0,0,0,0,0,8,4,0,1],
  [1,0,1,1,14,1,1,14,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,0,1,1,14,14,1,0,1,1,0,0,1,0,0,1],
  [1,0,5,0,14,14,14,14,1,0,3,0,12,5,0,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,12,6,1,0,0,1],
  [1,0,14,1,1,14,14,14,1,0,11,0,12,12,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
  [1,0,14,1,1,14,14,14,0,0,3,0,12,12,0,1,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
  [1,0,14,14,14,14,14,14,1,0,11,0,12,12,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,12,5,1,0,0,1],
  [1,0,1,1,14,1,1,14,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,0,0,1,0,9,1],
  [1,0,14,14,14,14,14,14,0,0,0,0,0,0,0,0,0,0,14,14,14,14,14,14,0,0,0,0,0,0,0,0,0,0,12,0,1,0,0,1],
  [1,0,14,1,1,14,14,14,1,0,3,0,12,12,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
  [1,0,4,1,1,14,14,14,1,0,11,0,12,12,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
  [1,0,14,14,14,14,14,14,1,0,0,0,12,12,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,12,5,1,0,0,1],
  [1,0,1,1,14,1,1,14,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
  [1,0,14,14,14,14,14,14,0,0,0,0,0,0,0,0,0,0,14,14,14,14,14,14,0,0,0,0,0,0,0,0,0,0,12,0,1,0,0,1],
  [1,0,14,1,1,14,14,14,1,0,3,0,12,12,0,1,1,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
  [1,0,14,1,1,14,14,14,1,0,11,0,12,12,0,1,1,0,0,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,0,1],
  [1,0,14,14,14,14,14,14,1,0,0,0,12,12,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,12,5,1,0,0,1],
  [1,0,1,1,14,1,1,14,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,0,0,1,8,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];
// Pre-calc
const ROWS = MAP.length, COLS = MAP[0].length;

// Camera
const cam = {x:0,y:0};

// Weather
const WEATHER_TYPES = ['Clear','Rain','Fog','Storm'];
let weather = WEATHER_TYPES[Math.floor(Math.random()*WEATHER_TYPES.length)];
let rainDrops = [];
let lightningTimer = 0;

// Entities
const spawn = findTile(2) || {x:TILE*2,y:TILE*2};
const player = { x:spawn.x, y:spawn.y, r:12, speed:2.1, sprint:3.3, vx:0, vy:0, stamina:100, flashlight:false, facing:0, hidden:false, inCrawl:false };
const enemy = { x: spawn.x+220, y: spawn.y+40, r:14, speed:1.85, fov: Math.PI/4.5, baseRange: 260, alert:false, target:null, patrol:[], patrolIndex:0, cooldown:0, fakeoutTimer:0 };

enemy.patrol = [
  {x:TILE*8,  y:TILE*3},
  {x:TILE*8,  y:TILE*16},
  {x:TILE*22, y:TILE*16},
  {x:TILE*34, y:TILE*16},
  {x:TILE*34, y:TILE*4},
  {x:TILE*22, y:TILE*4},
];

// Interactive sets:
let lockers = tilesToPoints(5);
let terminals = tilesToPoints(6);
let crawlFloors = tilesToPoints(8);           // vent floor network
let crawlEntrances = guessCrawlEntrances();   // auto-detected positions near crawl floors
let exitGate = findTile(9);
let doors = buildDoors();                     // {r,c,open:false}

// Key fragments: choose 8 random classroom interior spots (tile==4 markers)
const FRAGMENTS_NEEDED = 8;
let fragments = [];
resetFragments();

// Systems
let fragmentsHeld = 0;
let hasMasterKey = false;
let running = false;
let won = false;
let camAlertTimer = 0;
let camerasDisabledTimer = 0;
let lightLevel = 1;
let flickerTimer = 0;
let blackoutTimer = 0;
const HEAR_RANGE = 280;

// Input (keyboard + mobile)
const input = { up:false, down:false, left:false, right:false, sprint:false, interact:false };
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowUp'||e.key==='w' || e.key==='W') input.up = true;
  if(e.key==='ArrowDown'||e.key==='s'|| e.key==='S') input.down = true;
  if(e.key==='ArrowLeft'||e.key==='a'|| e.key==='A') input.left = true;
  if(e.key==='ArrowRight'||e.key==='d'|| e.key==='D') input.right = true;
  if(e.key==='Shift') input.sprint = true;
  if(e.key==='f'||e.key==='F') player.flashlight = !player.flashlight;
  if(e.key==='e'||e.key==='E') input.interact = true;
});
window.addEventListener('keyup', e=>{
  if(e.key==='ArrowUp'||e.key==='w'||e.key==='W') input.up = false;
  if(e.key==='ArrowDown'||e.key==='s'||e.key==='S') input.down = false;
  if(e.key==='ArrowLeft'||e.key==='a'||e.key==='A') input.left = false;
  if(e.key==='ArrowRight'||e.key==='d'||e.key==='D') input.right = false;
  if(e.key==='Shift') input.sprint = false;
  if(e.key==='e'||e.key==='E') input.interact = false;
});

// Cameras (same as before, placed in halls)
const cameras = [
  {x:TILE*10.5, y:TILE*2.5, range:240, fov:Math.PI/5, angle:0, min:-Math.PI/3, max:Math.PI/3, dir:1, speed:0.01, cooldown:0},
  {x:TILE*22.5, y:TILE*12.5, range:260, fov:Math.PI/5, angle:Math.PI, min:Math.PI-0.9, max:Math.PI+0.9, dir:1, speed:0.012, cooldown:0},
  {x:TILE*35.5, y:TILE*4.5,  range:220, fov:Math.PI/6, angle:Math.PI/2, min:Math.PI/2-0.7, max:Math.PI/2+0.7, dir:1, speed:0.009, cooldown:0},
  {x:TILE*16.5, y:TILE*8.5,  range:220, fov:Math.PI/6, angle:-Math.PI/2, min:-Math.PI/2-0.7, max:-Math.PI/2+0.7, dir:1, speed:0.011, cooldown:0},
];

// ===== Helpers =====
function tileAt(x,y){
  const c = Math.floor(x / TILE), r = Math.floor(y / TILE);
  if(r<0||r>=ROWS||c<0||c>=COLS) return 1;
  return MAP[r][c];
}
function findTile(n){
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(MAP[r][c]===n) return {x:c*TILE+TILE/2, y:r*TILE+TILE/2, r, c};
  return null;
}
function tilesToPoints(n){
  const arr=[];
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(MAP[r][c]===n) arr.push({x:c*TILE+TILE/2,y:r*TILE+TILE/2,r,c});
  return arr;
}
function clamp(v,mi,ma){ return Math.max(mi, Math.min(ma, v)); }
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function angle(a,b){ return Math.atan2(b.y-a.y, b.x-a.x); }
function normalizeAngle(a){ while(a>Math.PI) a-=2*Math.PI; while(a<-Math.PI) a+=2*Math.PI; return a; }
function enemyFacing(e){ if(e.target) return angle(e,e.target); const next=e.patrol[e.patrolIndex%e.patrol.length]; return angle(e,next); }

function collideCircleWalls(obj){
  // Doors behave like walls when closed (tile 3)
  function isBlocking(x,y){
    const t = tileAt(x,y);
    if(t===1) return true;
    if(t===3) return true; // closed door
    return false;
  }
  if(isBlocking(obj.x+obj.vx+Math.sign(obj.vx)*obj.r, obj.y)) obj.vx = 0;
  if(isBlocking(obj.x, obj.y+obj.vy+Math.sign(obj.vy)*obj.r)) obj.vy = 0;
  if(isBlocking(obj.x+Math.sign(obj.vx)*obj.r, obj.y+Math.sign(obj.vy)*obj.r)){ obj.vx=0; obj.vy=0; }
}

function canSeeCone(from,to, angleCenter, fov, maxDist){
  const ang = angle(from,to);
  const withinCone = Math.abs(normalizeAngle(ang - angleCenter)) <= fov/2;
  if(!withinCone) return false;
  const d = dist(from, to); if(d>maxDist) return false;
  const steps = Math.ceil(d/6);
  for(let i=1;i<=steps;i++){
    const px = from.x + (to.x-from.x)*(i/steps);
    const py = from.y + (to.y-from.y)*(i/steps);
    if(tileBlocksVision(px,py)) return false;
  }
  return true;
}
function tileBlocksVision(x,y){
  const t = tileAt(x,y);
  if(t===1) return true;
  if(t===3) return true; // closed door blocks vision
  return false;
}

// ===== Doors =====
function buildDoors(){
  const arr=[];
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    if(MAP[r][c]===3) arr.push({r,c, open:false});
  }
  return arr;
}
function isNearDoor(){
  for(const d of doors){
    const x = d.c*TILE+TILE/2, y = d.r*TILE+TILE/2;
    if(dist(player,{x,y})<26) return d;
  }
  return null;
}
function toggleDoor(d){
  d.open = !d.open;
  MAP[d.r][d.c] = d.open ? 0 : 3;
}

// ===== Crawlspaces =====
function guessCrawlEntrances(){
  // any crawl tile (8) that touches a floor (0/14) via cardinal direction is an entrance
  const entries=[];
  for(const v of tilesToPoints(8)){
    const {r,c} = v;
    const neigh = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
    for(const [rr,cc] of neigh){
      if(rr<0||cc<0||rr>=ROWS||cc>=COLS) continue;
      const t = MAP[rr][cc];
      if(t===0 || t===14){ entries.push({x: c*TILE+TILE/2, y:r*TILE+TILE/2}); break; }
    }
  }
  return entries;
}
function nearCrawlEntrance(){
  for(const e of crawlEntrances) if(dist(player,e)<26) return e;
  return null;
}
function isOnCrawlFloor(p){ return tileAt(p.x,p.y)===8; }

// ===== Fragments / Master Key =====
function resetFragments(){
  const classroomSpots = tilesToPoints(4); // markers inside rooms
  shuffle(classroomSpots);
  fragments = classroomSpots.slice(0, FRAGMENTS_NEEDED).map(p=>({x:p.x,y:p.y,taken:false}));
  fragmentsHeld = 0;
  hasMasterKey = false;
}
function checkMaster(){
  if(!hasMasterKey && fragmentsHeld>=FRAGMENTS_NEEDED){
    hasMasterKey = true;
  }
}
function shuffle(a){
  for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; }
  return a;
}

// ===== Cameras/Enemy/Lighting =====
function canSeeEnemy(){
  const ambientFactor =
    (weather==='Fog' ? 0.65 : 1.0) *
    (weather==='Storm' && lightningTimer>0 ? 1.25 : 1.0) *
    (blackoutTimer>0 ? 0.6 : (0.85 + 0.15*lightLevel));
  const baseRange = enemy.baseRange * ambientFactor * (player.flashlight ? 1.15 : 1.0);
  const facing = enemyFacing(enemy);
  return canSeeCone(enemy, player, facing, enemy.fov, baseRange);
}

// ===== Game Flow =====
let gameOver = false;

function reset(){
  // weather
  weather = WEATHER_TYPES[Math.floor(Math.random()*WEATHER_TYPES.length)];
  rainDrops = [];
  if(weather==='Rain' || weather==='Storm'){
    for(let i=0;i<140;i++){
      rainDrops.push({x:Math.random()*COLS*TILE, y:Math.random()*ROWS*TILE, z:0.5+Math.random()*1.2});
    }
  }
  lightningTimer = 0;

  // player/enemy
  player.x = spawn.x; player.y = spawn.y; player.vx=player.vy=0;
  player.stamina=100; player.flashlight=false; player.hidden=false; player.inCrawl=false;
  enemy.x = spawn.x+220; enemy.y = spawn.y+40; enemy.alert=false; enemy.target=null; enemy.patrolIndex=0; enemy.cooldown=0; enemy.fakeoutTimer=0;

  // doors closed
  doors.forEach(d=>{ d.open=false; MAP[d.r][d.c]=3; });

  // cams / light
  camerasDisabledTimer = 0; uiCams.textContent='Online';
  alertEl.style.display='none';
  lightLevel=1; flickerTimer=0; blackoutTimer=0;

  // keys
  resetFragments();

  running = true; gameOver=false; won=false;
  overlay.style.display='none';
  playBtn.style.display='none';
  retryBtn.style.display='none';
  uiWeather.textContent=weather;
}

function endGame(){
  running=false;
  overlay.style.display='flex';
  retryBtn.style.display='inline-block';
  playBtn.style.display='none';
  titleEl.textContent = won ? "You Escaped Outside" : "Caught by Mr. Johnson";
  msgEl.textContent = won
    ? "The courtyard gate clangs open. Cold air. Freedom."
    : "Detention… forever. Tips: Use doors to break sightlines, go through vents (E), and craft the Master Key by finding all 8 fragments in classrooms.";
}

// ===== Interaction =====
function nearThing(list, radius=24){ for(const p of list){ if(dist(player,p)<radius) return p; } return null; }
function nearLocker(){ return nearThing(lockers, 26); }
function nearTerminal(){ return nearThing(terminals, 28); }
function nearExitGate(){ return exitGate && dist(player,exitGate)<28; }

function tryInteract(){
  // Exit vent / crawl
  if(player.inCrawl){
    // If player steps onto non-crawl tile, auto-pop; otherwise allow manual pop on entrance spot
    const e = nearCrawlEntrance();
    if(e){ player.inCrawl=false; player.hidden=false; return; }
  } else {
    const e = nearCrawlEntrance();
    if(e){ player.inCrawl = true; player.hidden=true; player.flashlight=false; return; }
  }

  // Doors
  const d = isNearDoor();
  if(d){ toggleDoor(d); return; }

  // Terminals
  const term = nearTerminal();
  if(term){ camerasDisabledTimer = 60*30; uiCams.textContent='Offline'; return; }

  // Lockers
  const locker = nearLocker();
  if(locker){ player.hidden = !player.hidden; if(player.hidden){ player.flashlight=false; player.vx=player.vy=0; } return; }

  // Exit gate
  if(nearExitGate()){
    if(hasMasterKey){ won=true; endGame(); }
    return;
  }
}

// ===== Update Loop =====
function update(){
  requestAnimationFrame(update);

  // Camera follow
  cam.x = clamp(player.x - W/2, 0, COLS*TILE - W);
  cam.y = clamp(player.y - H/2, 0, ROWS*TILE - H);

  if(!running){ draw(); return; }

  // Weather steps
  if(weather==='Storm'){
    if(Math.random()<0.003 && lightningTimer===0) lightningTimer = 12; // short flash
    if(lightningTimer>0) lightningTimer--;
  }
  if(weather==='Rain' || weather==='Storm'){
    for(const drop of rainDrops){
      drop.y += 6*drop.z + (player.vy*0.02);
      drop.x += -1.5*drop.z + (player.vx*0.02);
      if(drop.y > ROWS*TILE) { drop.y = -10; drop.x = (drop.x+1000)%(COLS*TILE); }
    }
  }

  // Lighting
  if(blackoutTimer>0){ blackoutTimer--; lightLevel = 0.25; }
  else {
    if(flickerTimer>0){ flickerTimer--; lightLevel = 0.7 + Math.random()*0.2; }
    else {
      lightLevel = 1;
      if(Math.random()<0.003) flickerTimer = 40;
      if(Math.random()<0.0008) blackoutTimer = 180;
    }
  }

  // Input & interact one-shot
  if(input.interact){ tryInteract(); input.interact=false; }

  // Movement (crawlspaces: slower, invisible already via hidden=true)
  let speed = player.inCrawl ? 1.6 : player.speed;
  if(input.sprint && player.stamina>0 && !player.inCrawl) speed = player.sprint;

  player.vx = (input.right - input.left) * speed;
  player.vy = (input.down - input.up) * speed;
  if(player.vx && player.vy){ player.vx *= 0.7071; player.vy *= 0.7071; }

  const moving = (player.vx||player.vy);
  if(input.sprint && moving && !player.inCrawl) player.stamina = Math.max(0, player.stamina - 0.25);
  else player.stamina = Math.min(100, player.stamina + (player.hidden?0.4:0.15));

  collideCircleWalls(player);

  // If in crawl, clamp to crawl network
  if(player.inCrawl && !isOnCrawlFloor({x:player.x+player.vx, y:player.y+player.vy})){
    // gentle nudge: reduce motion that would leave vents
    player.vx *= 0.3; player.vy *= 0.3;
  }

  player.x += player.vx; player.y += player.vy;
  if(moving) player.facing = Math.atan2(player.vy, player.vx);

  // Noise from sprinting
  if(input.sprint && moving && !player.inCrawl){
    const d = dist(player, enemy);
    if(d < HEAR_RANGE){ enemy.alert = true; enemy.target = {x:player.x, y:player.y}; enemy.cooldown = 180; }
  }

  // Collect fragments
  for(const f of fragments){
    if(!f.taken && dist(player,f)<18){
      f.taken = true;
      fragmentsHeld++;
      checkMaster();
    }
  }

  // Cameras
  if(camerasDisabledTimer>0){ camerasDisabledTimer--; if(camerasDisabledTimer===0) uiCams.textContent='Online'; }
  for(const camObj of cameras){
    camObj.angle += camObj.speed * camObj.dir;
    if(camObj.angle>camObj.max){ camObj.angle=camObj.max; camObj.dir*=-1; }
    if(camObj.angle<camObj.min){ camObj.angle=camObj.min; camObj.dir*=-1; }

    if(player.hidden) continue;
    if(camerasDisabledTimer>0) continue;
    if(canSeeCone(camObj, player, camObj.angle, camObj.fov, camObj.range)){
      camObj.cooldown = 180;
      camAlertTimer = 60; alertEl.style.display='block';
      enemy.alert = true; enemy.target = {x:player.x, y:player.y}; enemy.cooldown = 300;
    } else if(camObj.cooldown>0){ camObj.cooldown--; }
  }
  if(camAlertTimer>0){ camAlertTimer--; if(camAlertTimer===0) alertEl.style.display='none'; }

  // Enemy AI
  const seen = !player.hidden && canSeeEnemy();
  if(!enemy.alert && !player.hidden){
    const toPlayer = angle(enemy, player);
    const face = enemyFacing(enemy);
    const behind = Math.abs(normalizeAngle(toPlayer - face)) > Math.PI*0.7;
    if(behind && dist(player, enemy) < 140){ if(enemy.fakeoutTimer<=0) enemy.fakeoutTimer = 60; }
  }
  if(seen){ enemy.alert = true; enemy.target = {x:player.x, y:player.y}; enemy.cooldown = 240; enemy.fakeoutTimer = 0; }
  else { if(enemy.cooldown>0) enemy.cooldown--; else enemy.alert=false; }

  if(enemy.alert){
    const ang = angle(enemy, enemy.target);
    const spd = enemy.speed + 0.4;
    enemy.x += Math.cos(ang) * spd;
    enemy.y += Math.sin(ang) * spd;
    if(dist(enemy, enemy.target)<12) enemy.alert=false;
  } else {
    if(enemy.fakeoutTimer>0){
      enemy.fakeoutTimer--;
      const prevIndex = (enemy.patrolIndex - 1 + enemy.patrol.length) % enemy.patrol.length;
      const wp = enemy.patrol[prevIndex];
      const ang = angle(enemy, wp);
      enemy.x += Math.cos(ang) * (enemy.speed + 0.8);
      enemy.y += Math.sin(ang) * (enemy.speed + 0.8);
      if(dist(enemy, wp)<14 || enemy.fakeoutTimer===0) enemy.patrolIndex = prevIndex;
    } else {
      const wp = enemy.patrol[enemy.patrolIndex % enemy.patrol.length];
      const ang = angle(enemy, wp);
      enemy.x += Math.cos(ang) * enemy.speed;
      enemy.y += Math.sin(ang) * enemy.speed;
      if(dist(enemy, wp)<12) enemy.patrolIndex = (enemy.patrolIndex+1) % enemy.patrol.length;
      if(Math.random()<0.0015){ enemy.fakeoutTimer = 50; }
    }
  }
  enemy.vx = enemy.vy = 0;
  collideCircleWalls(enemy);

  // Caught?
  if(!player.hidden && dist(player, enemy) < 16){ gameOver = true; endGame(); }

  // UI
  uiKeys.textContent = `${fragmentsHeld}`;
  uiMaster.textContent = hasMasterKey ? 'Yes' : 'No';
  uiStam.textContent = `${Math.round(player.stamina)}`;
  uiHidden.textContent = player.hidden ? 'Yes' : 'No';
  if(camerasDisabledTimer>0) uiCams.textContent = `Offline ${Math.ceil(camerasDisabledTimer/60)}s`;

  draw();
}

// ===== Draw =====
function draw(){
  ctx.fillStyle = '#07070b';
  ctx.fillRect(0,0,W,H);

  // Visible tile bounds
  const c0 = Math.max(0, Math.floor(cam.x / TILE) - 1);
  const r0 = Math.max(0, Math.floor(cam.y / TILE) - 1);
  const c1 = Math.min(COLS-1, Math.ceil((cam.x+W) / TILE) + 1);
  const r1 = Math.min(ROWS-1, Math.ceil((cam.y+H) / TILE) + 1);

  for(let r=r0;r<=r1;r++){
    for(let c=c0;c<=c1;c++){
      const t = MAP[r][c];
      const x=c*TILE - cam.x, y=r*TILE - cam.y;

      // base floor/wall
      if(t===1){
        ctx.fillStyle = '#161622';
        ctx.fillRect(x,y,TILE,TILE);
      } else {
        ctx.fillStyle = (t===14)?'#0f111b':'#0f0f18'; // halls slightly different tint
        if(t===8) ctx.fillStyle = '#0b1014'; // crawlspace darker
        ctx.fillRect(x,y,TILE,TILE);
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.strokeRect(x+0.5,y+0.5,TILE-1,TILE-1);
      }

      // Doors / frames / props
      if(t===3){ // closed door
        ctx.fillStyle = '#5b4333';
        ctx.fillRect(x+2,y+2,TILE-4,TILE-4);
        ctx.fillStyle = '#bfa17a';
        ctx.fillRect(x+TILE-10,y+TILE/2-3,6,6);
      }
      if(t===11){ // frame
        ctx.fillStyle = '#2a2420'; ctx.fillRect(x+2,y+2,TILE-4,TILE-4);
      }
      if(t===12){ // desks
        ctx.fillStyle = '#2b2b38'; ctx.fillRect(x+6,y+8,TILE-12,TILE-12);
        ctx.fillStyle = '#0b0b10'; ctx.fillRect(x+10,y+12,TILE-20,TILE-20);
      }
      if(t===5){ // lockers
        ctx.fillStyle = '#1b3b6f'; ctx.fillRect(x+4,y+4,TILE-8,TILE-8);
        ctx.fillStyle = '#8bb5ff'; ctx.fillRect(x+TILE-10,y+TILE/2-3,6,6);
      }
      if(t===6){ // terminals
        ctx.fillStyle = camerasDisabledTimer>0 ? '#2a823a' : '#4062b2';
        ctx.fillRect(x+6,y+6,TILE-12,TILE-12);
        ctx.fillStyle = '#0b0b10'; ctx.fillRect(x+10,y+10,TILE-20,TILE-20);
      }
      if(t===8){ // crawl floor hatch texture hint
        ctx.fillStyle = '#0d1a22';
        ctx.fillRect(x+8,y+8,TILE-16,TILE-16);
        ctx.fillStyle = '#0a1318';
        ctx.fillRect(x+10,y+10,TILE-20,TILE-20);
      }
      if(t===9){ // exit gate
        ctx.fillStyle = hasMasterKey ? '#3fa370' : '#704040';
        ctx.fillRect(x+2,y+2,TILE-4,TILE-4);
      }
    }
  }

  // Fragments
  for(const f of fragments){
    if(f.taken) continue;
    const sx=f.x - cam.x, sy=f.y - cam.y;
    if(sx<-20||sy<-20||sx>W+20||sy>H+20) continue;
    ctx.fillStyle='#e8c547';
    ctx.beginPath(); ctx.arc(sx,sy,6,0,Math.PI*2); ctx.fill();
  }

  // Cameras FOV/body
  for(const camObj of cameras){
    const sx=camObj.x - cam.x, sy=camObj.y - cam.y;
    if(camerasDisabledTimer<=0){
      ctx.save();
      ctx.fillStyle = 'rgba(80,140,255,0.08)';
      drawCone(sx, sy, camObj.angle, camObj.fov, camObj.range);
      ctx.restore();
    }
    ctx.fillStyle = camerasDisabledTimer>0 ? '#2a823a' : '#4a73c2';
    ctx.beginPath();
    ctx.moveTo(sx+Math.cos(camObj.angle)*10, sy+Math.sin(camObj.angle)*10);
    ctx.lineTo(sx+Math.cos(camObj.angle+0.8)*10, sy+Math.sin(camObj.angle+0.8)*10);
    ctx.lineTo(sx+Math.cos(camObj.angle-0.8)*10, sy+Math.sin(camObj.angle-0.8)*10);
    ctx.closePath(); ctx.fill();
    if(camObj.cooldown>0 && camerasDisabledTimer<=0){
      ctx.fillStyle = '#ff5d5d';
      ctx.beginPath(); ctx.arc(sx, sy, 3, 0, Math.PI*2); ctx.fill();
    }
  }

  // Enemy FOV
  const face = enemyFacing(enemy);
  const ambient = (blackoutTimer>0 ? 0.6 : (0.8 + 0.2*lightLevel));
  const eRange = enemy.baseRange * ambient;
  ctx.save();
  ctx.fillStyle = 'rgba(255,80,80,0.08)';
  drawCone(enemy.x - cam.x, enemy.y - cam.y, face, enemy.fov, eRange);
  ctx.restore();

  // Player flashlight
  if(player.flashlight && !player.hidden){
    const coneAngle = player.facing, coneWidth = Math.PI/5, coneRange = 240;
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle='rgba(180,180,200,0.12)';
    drawCone(player.x - cam.x, player.y - cam.y, coneAngle, coneWidth, coneRange);
    ctx.restore();
  }

  // Darkness & weather fog
  let darkBase = 0.55 + (1-lightLevel)*0.6;
  if(weather==='Fog') darkBase += 0.08;
  if(weather==='Rain') darkBase += 0.03;
  if(weather==='Storm') darkBase += (lightningTimer>0 ? -0.2 : 0.06);
  const dark = clamp(darkBase, 0, 0.95);
  ctx.fillStyle = `rgba(0,0,0,${dark})`;
  ctx.fillRect(0,0,W,H);

  // Rain overlay
  if(weather==='Rain' || weather==='Storm'){
    ctx.strokeStyle = 'rgba(180,180,200,0.25)';
    ctx.lineWidth = 1;
    for(const drop of rainDrops){
      const sx = drop.x - cam.x, sy = drop.y - cam.y;
      if(sx<-20||sy<-20||sx>W+20||sy>H+20) continue;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx-6*drop.z, sy+12*drop.z);
      ctx.stroke();
    }
  }

  // Entities
  // Player: disappear if hidden *inside crawlspace*
  if(!(player.inCrawl)){ // if in crawlspace, fully invisible by request
    if(!player.hidden){
      ctx.fillStyle = '#8bb5ff';
      ctx.beginPath(); ctx.arc(player.x - cam.x, player.y - cam.y, player.r, 0, Math.PI*2); ctx.fill();
    } else {
      // Slight silhouette when hiding in locker (optional): comment to remove
      ctx.fillStyle = 'rgba(139,181,255,0.18)';
      ctx.beginPath(); ctx.arc(player.x - cam.x, player.y - cam.y, player.r, 0, Math.PI*2); ctx.fill();
    }
  }

  // Enemy (same stylization)
  ctx.fillStyle = '#4b3424';
  ctx.beginPath(); ctx.arc(enemy.x - cam.x, enemy.y - cam.y, enemy.r+1, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = '#141414';
  ctx.beginPath();
  ctx.arc(enemy.x - cam.x, enemy.y - cam.y + 2, enemy.r-2, Math.PI*0.15, Math.PI-0.15);
  ctx.lineTo(enemy.x - cam.x, enemy.y - cam.y + 3);
  ctx.closePath(); ctx.fill();
  ctx.strokeStyle = '#0d0d0d';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(enemy.x - cam.x, enemy.y - cam.y + 1, enemy.r-6, Math.PI*0.05, Math.PI-0.05);
  ctx.stroke();
  if(enemy.alert){
    ctx.fillStyle = '#ff5d5d';
    ctx.beginPath(); ctx.arc(enemy.x - cam.x, enemy.y - cam.y - enemy.r - 10, 4, 0, Math.PI*2); ctx.fill();
  }
}

function drawCone(x,y,angleCenter, angleWidth, radius){
  ctx.beginPath();
  ctx.moveTo(x,y);
  ctx.arc(x,y, radius, angleCenter - angleWidth/2, angleCenter + angleWidth/2);
  ctx.closePath();
  ctx.fill();
}

// ===== Mobile Controls (joystick & buttons) =====
let joyActive = false, joyStart = {x:0,y:0}, joyVec = {x:0,y:0};
function setStickListeners(){
  function pos(e){
    const rect = stick.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    let x,y;
    if(e.touches && e.touches[0]){ x=e.touches[0].clientX; y=e.touches[0].clientY; }
    else { x=e.clientX; y=e.clientY; }
    return {x, y, cx, cy, r: rect.width/2 - 8};
  }
  function start(e){ e.preventDefault(); joyActive=true; joyVec.x=joyVec.y=0; }
  function move(e){
    if(!joyActive) return;
    const p = pos(e);
    const dx = p.x - p.cx, dy = p.y - p.cy;
    const len = Math.hypot(dx,dy);
    const r = p.r;
    const nx = (len>r? dx/len*r : dx), ny = (len>r? dy/len*r : dy);
    nub.style.transform = `translate(${nx}px, ${ny}px) translate(-50%,-50%)`;
    const mag = Math.min(1, len/r);
    joyVec.x = (nx/r) * mag;
    joyVec.y = (ny/r) * mag;
    input.left = joyVec.x < -0.2;
    input.right = joyVec.x > 0.2;
    input.up = joyVec.y < -0.2;
    input.down = joyVec.y > 0.2;
  }
  function end(){ joyActive=false; joyVec.x=joyVec.y=0; nub.style.transform='translate(-50%,-50%)'; input.left=input.right=input.up=input.down=false; }
  stick.addEventListener('touchstart', start, {passive:false});
  stick.addEventListener('touchmove', move, {passive:false});
  stick.addEventListener('touchend', end);
  stick.addEventListener('mousedown', start);
  window.addEventListener('mousemove', move);
  window.addEventListener('mouseup', end);

  // Buttons
  btnInteract.addEventListener('touchstart', e=>{ e.preventDefault(); input.interact=true; });
  btnInteract.addEventListener('touchend', ()=>{ input.interact=false; });
  btnInteract.addEventListener('mousedown', ()=>{ input.interact=true; });
  btnInteract.addEventListener('mouseup', ()=>{ input.interact=false; });

  btnFlash.addEventListener('click', ()=>{ player.flashlight=!player.flashlight; });
  btnFlash.addEventListener('touchstart', e=>{ e.preventDefault(); player.flashlight=!player.flashlight; });

  btnSprint.addEventListener('touchstart', e=>{ e.preventDefault(); input.sprint=true; });
  btnSprint.addEventListener('touchend', ()=>{ input.sprint=false; });
  btnSprint.addEventListener('mousedown', ()=>{ input.sprint=true; });
  btnSprint.addEventListener('mouseup', ()=>{ input.sprint=false; });
}

// ===== Boot =====
const playBtnEl = document.getElementById('play');
const retryBtnEl = document.getElementById('retry');
playBtn.onclick = ()=>{ reset(); };
retryBtn.onclick = ()=>{ reset(); };
overlay.style.display='flex';
setStickListeners();
requestAnimationFrame(update);

</script>
</body>
</html>
